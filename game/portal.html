<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rick & Morty Portal</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      color: white;
      font-family: sans-serif;
      font-size: 2em;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="overlay">Подойди к порталу...</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
uniform float time;
varying vec2 vUv;
void main() {
  vUv = uv;
  vec3 pos = position;
  float dist = distance(uv, vec2(0.5));
  pos.z += sin(dist * 40.0 - time * 2.0) * 2.0;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
uniform float time;
varying vec2 vUv;

float circle(vec2 uv, vec2 disc_center, float disc_radius, float border) {
  float dist = distance(uv, disc_center);
  return smoothstep(disc_radius + border, disc_radius - border, dist);
}

void main() {
  vec2 uv = vUv;
  vec3 color = vec3(0.0);
  float c = circle(uv, vec2(0.5), 0.45 + 0.02 * sin(time * 2.0), 0.03);
  
  float rings = sin((distance(uv, vec2(0.5)) - time * 0.2) * 60.0) * 0.5 + 0.5;
  rings *= circle(uv, vec2(0.5), 0.5, 0.2);
  
  color = mix(vec3(0.0), vec3(0.1, 1.0, 0.2), c);
  color += rings * vec3(0.3, 1.0, 0.1);
  
  // speckles
  float noise = fract(sin(dot(uv * time, vec2(12.9898,78.233))) * 43758.5453);
  if (noise > 0.995) color = vec3(1.0);

  gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
let scene, camera, renderer, mesh, uniforms, clock;
let overlay = document.getElementById('overlay');
let teleported = false;

init();
animate();

function init() {
  scene = new THREE.Scene();
  clock = new THREE.Clock();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.z = 5;

  const geometry = new THREE.PlaneGeometry(4, 4, 128, 128);

  uniforms = {
    time: { value: 0 }
  };

  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent
  });

  mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('click', onClick);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onPointerMove(e) {
  let x = (e.clientX / window.innerWidth) * 2 - 1;
  let y = -(e.clientY / window.innerHeight) * 2 + 1;
  if (!teleported) {
    mesh.rotation.z = x * 0.2;
    mesh.scale.setScalar(1 + 0.1 * (1 - Math.abs(x)));
  }
}

function onClick() {
  if (teleported) return;
  teleported = true;

  overlay.textContent = "Телепортация...";
  let scale = { value: 1 };
  let t = 0;

  const teleportAnim = () => {
    t += 0.02;
    scale.value = 1 + t * 5;
    mesh.scale.setScalar(scale.value);
    camera.fov = 60 + t * 50;
    camera.updateProjectionMatrix();
    if (t < 1) {
      requestAnimationFrame(teleportAnim);
    } else {
      enterOtherWorld();
    }
  };
  teleportAnim();
}

function enterOtherWorld() {
  scene.background = new THREE.Color('#202');
  mesh.material.fragmentShader = `
    void main() {
      gl_FragColor = vec4(0.1, 0.05, 0.15, 1.0);
    }
  `;
  mesh.material.needsUpdate = true;
  overlay.textContent = "Ты в другой вселенной!";
}

function animate() {
  requestAnimationFrame(animate);
  uniforms.time.value = clock.getElapsedTime();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
